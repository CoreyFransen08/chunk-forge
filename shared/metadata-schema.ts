/**
 * Custom Metadata Schema Types
 *
 * Defines user-definable metadata schemas for documents and chunks
 * with typed fields (string, numeric, JSON, array).
 */

import { z } from 'zod';

// =============================================================================
// Field Types
// =============================================================================

export const fieldTypeSchema = z.enum(['string', 'numeric', 'json', 'array']);
export type FieldType = z.infer<typeof fieldTypeSchema>;

// =============================================================================
// Validation Rules (optional per field)
// =============================================================================

export const fieldValidationSchema = z.object({
  // String validation
  minLength: z.number().optional(),
  maxLength: z.number().optional(),
  pattern: z.string().optional(),

  // Numeric validation
  min: z.number().optional(),
  max: z.number().optional(),
  integer: z.boolean().optional(),

  // Array validation
  minItems: z.number().optional(),
  maxItems: z.number().optional(),
}).optional();

export type FieldValidation = z.infer<typeof fieldValidationSchema>;

// =============================================================================
// Field Definition
// =============================================================================

export const fieldDefinitionSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1).max(50).regex(/^[a-z][a-z0-9_]*$/, {
    message: 'Field name must start with lowercase letter and contain only lowercase letters, numbers, and underscores',
  }),
  label: z.string().min(1).max(100),
  type: fieldTypeSchema,
  required: z.boolean().default(false),
  autoGenerated: z.boolean().default(false), // If true, system populates this field (read-only in UI)
  defaultValue: z.union([
    z.string(),
    z.number(),
    z.record(z.string(), z.string()), // Flat JSON only
    z.array(z.string()),
  ]).optional(),
  description: z.string().max(500).optional(),
  validation: fieldValidationSchema,
});

export type FieldDefinition = z.infer<typeof fieldDefinitionSchema>;

// =============================================================================
// Metadata Schema (full definition)
// =============================================================================

export const metadataSchemaSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1).max(100),
  description: z.string().max(500).optional(),
  documentFields: z.array(fieldDefinitionSchema).default([]),
  chunkFields: z.array(fieldDefinitionSchema).default([]),
  chunkEnrichmentPrompt: z.string().max(5000).optional().nullable(),
  createdAt: z.string().optional(),
  updatedAt: z.string().optional(),
});

export type MetadataSchema = z.infer<typeof metadataSchemaSchema>;

// =============================================================================
// Custom Field Values (supports all types)
// =============================================================================

export const customFieldValueSchema = z.union([
  z.string(),
  z.number(),
  z.record(z.string(), z.string()), // Flat JSON only
  z.array(z.string()),
]).nullable();

export type CustomFieldValue = z.infer<typeof customFieldValueSchema>;

export const customFieldsSchema = z.record(z.string(), customFieldValueSchema);
export type CustomFields = z.infer<typeof customFieldsSchema>;

// =============================================================================
// API Request/Response Types
// =============================================================================

export const createSchemaRequestSchema = z.object({
  name: z.string().min(1).max(100),
  description: z.string().max(500).optional(),
  documentFields: z.array(fieldDefinitionSchema).default([]),
  chunkFields: z.array(fieldDefinitionSchema).default([]),
  chunkEnrichmentPrompt: z.string().max(5000).optional().nullable(),
});

export type CreateSchemaRequest = z.infer<typeof createSchemaRequestSchema>;

export const updateSchemaRequestSchema = z.object({
  name: z.string().min(1).max(100).optional(),
  description: z.string().max(500).optional(),
  documentFields: z.array(fieldDefinitionSchema).optional(),
  chunkFields: z.array(fieldDefinitionSchema).optional(),
  chunkEnrichmentPrompt: z.string().max(5000).optional().nullable(),
});

export type UpdateSchemaRequest = z.infer<typeof updateSchemaRequestSchema>;

export const applySchemaRequestSchema = z.object({
  schemaId: z.string().uuid().nullable(),
});

export type ApplySchemaRequest = z.infer<typeof applySchemaRequestSchema>;

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Get default value for a field type
 */
export function getDefaultValueForType(type: FieldType): CustomFieldValue {
  switch (type) {
    case 'string':
      return '';
    case 'numeric':
      return 0;
    case 'json':
      return {};
    case 'array':
      return [];
  }
}

/**
 * Validate a field value against its definition
 */
export function validateFieldValue(
  value: CustomFieldValue | undefined,
  field: FieldDefinition
): string | null {
  // Check required
  if (field.required && (value === undefined || value === '' || (Array.isArray(value) && value.length === 0))) {
    return `${field.label} is required`;
  }

  if (value === undefined) return null;

  const validation = field.validation;
  if (!validation) return null;

  // Type-specific validation
  switch (field.type) {
    case 'string':
      if (typeof value !== 'string') return `${field.label} must be a string`;
      if (validation.minLength && value.length < validation.minLength) {
        return `${field.label} must be at least ${validation.minLength} characters`;
      }
      if (validation.maxLength && value.length > validation.maxLength) {
        return `${field.label} must be at most ${validation.maxLength} characters`;
      }
      if (validation.pattern) {
        const regex = new RegExp(validation.pattern);
        if (!regex.test(value)) {
          return `${field.label} does not match the required pattern`;
        }
      }
      break;

    case 'numeric':
      if (typeof value !== 'number') return `${field.label} must be a number`;
      if (validation.min !== undefined && value < validation.min) {
        return `${field.label} must be at least ${validation.min}`;
      }
      if (validation.max !== undefined && value > validation.max) {
        return `${field.label} must be at most ${validation.max}`;
      }
      if (validation.integer && !Number.isInteger(value)) {
        return `${field.label} must be an integer`;
      }
      break;

    case 'array':
      if (!Array.isArray(value)) return `${field.label} must be an array`;
      if (validation.minItems && value.length < validation.minItems) {
        return `${field.label} must have at least ${validation.minItems} items`;
      }
      if (validation.maxItems && value.length > validation.maxItems) {
        return `${field.label} must have at most ${validation.maxItems} items`;
      }
      break;

    case 'json':
      if (typeof value !== 'object' || Array.isArray(value)) {
        return `${field.label} must be a JSON object`;
      }
      break;
  }

  return null;
}

/**
 * Generate a new UUID for field definitions
 */
export function generateFieldId(): string {
  return crypto.randomUUID();
}

/**
 * Create a new empty field definition
 */
export function createEmptyField(type: FieldType = 'string', autoGenerated: boolean = false): FieldDefinition {
  return {
    id: generateFieldId(),
    name: '',
    label: '',
    type,
    required: false,
    autoGenerated,
  };
}
