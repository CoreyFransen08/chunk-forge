# Custom Metadata Schemas

This document describes the custom metadata schema system in ChunkForge, allowing users to define reusable, typed metadata fields for documents and chunks.

## Overview

Custom schemas enable users to:
- Define typed metadata fields (string, numeric, array, JSON)
- Create reusable schema templates
- Apply schemas to documents for consistent metadata structure

**Important**: A schema is **required** when uploading a document. The schema determines which metadata fields are available and whether they are user-editable or auto-generated by the system.

## Default Schema

ChunkForge provides a built-in "Default" schema:

```typescript
export const DEFAULT_SCHEMA_ID = '00000000-0000-0000-0000-000000000001';
```

The Default schema is created via database initialization (`scripts/init-db.sql`) and includes:

**Document Fields (user-editable):**
- `title` - Document title
- `author` - Document author
- `description` - Document description

**Chunk Fields (user-editable):**
- `title`, `author` - Chunk-specific overrides
- `page` - Page number reference
- `tags`, `keywords` - Categorization arrays
- `summary` - Chunk summary

**Chunk Fields (auto-generated):**
- `heading_1` through `heading_6` - Heading hierarchy
- `section_path` - Full hierarchical path
- `heading_level` - Heading level (1-6)
- `token_count` - Number of tokens
- `position_in_document` - Zero-indexed position
- `total_chunks` - Total chunks in document

The Default schema is pre-selected in the upload dialog.

## Database Schema

### `metadata_schemas` Table

```sql
CREATE TABLE metadata_schemas (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  document_fields JSONB NOT NULL DEFAULT '[]',
  chunk_fields JSONB NOT NULL DEFAULT '[]',
  chunk_enrichment_prompt TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Drizzle ORM Definition** (`server/db-schema.ts`):

```typescript
export const metadataSchemas = pgTable(
  'metadata_schemas',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    name: text('name').notNull(),
    description: text('description'),
    documentFields: jsonb('document_fields').default([]).notNull().$type<FieldDefinition[]>(),
    chunkFields: jsonb('chunk_fields').default([]).notNull().$type<FieldDefinition[]>(),
    chunkEnrichmentPrompt: text('chunk_enrichment_prompt'),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
  }
);
```

### Column Descriptions

| Column | Type | Description |
|--------|------|-------------|
| `id` | UUID | Primary key, auto-generated |
| `name` | TEXT | Schema display name (1-100 chars) |
| `description` | TEXT | Optional description (max 500 chars) |
| `document_fields` | JSONB | Array of field definitions for documents |
| `chunk_fields` | JSONB | Array of field definitions for chunks |
| `chunk_enrichment_prompt` | TEXT | Optional AI enrichment prompt |
| `created_at` | TIMESTAMPTZ | Creation timestamp |
| `updated_at` | TIMESTAMPTZ | Last update timestamp |

### Relationship with Uploads

```sql
-- Uploads table references metadata_schemas
ALTER TABLE uploads
ADD COLUMN schema_id UUID REFERENCES metadata_schemas(id) ON DELETE SET NULL;

ADD COLUMN custom_metadata JSONB NOT NULL DEFAULT '{}';
```

When a schema is deleted, uploads using it have their `schema_id` set to `NULL` (orphaned custom metadata is preserved).

## Type Definitions

### Field Types

```typescript
type FieldType = 'string' | 'numeric' | 'json' | 'array';
```

| Type | Description | Storage | UI Component |
|------|-------------|---------|--------------|
| `string` | Single/multi-line text | `"value"` | Text input |
| `numeric` | Integer or decimal | `42` or `3.14` | Number input |
| `array` | List of strings | `["tag1", "tag2"]` | TagsInput |
| `json` | Flat key-value pairs | `{"key": "value"}` | JsonKeyValueEditor |

### Field Definition Schema

```typescript
interface FieldDefinition {
  id: string;           // UUID, unique within schema
  name: string;         // Field key (lowercase, underscores, 1-50 chars)
  label: string;        // Display label (1-100 chars)
  type: FieldType;      // 'string' | 'numeric' | 'json' | 'array'
  required: boolean;    // If true, must have value
  autoGenerated: boolean; // If true, system populates (read-only in UI)
  defaultValue?: CustomFieldValue;  // Initial value
  description?: string; // Help text (max 500 chars)
  validation?: FieldValidation;     // Type-specific rules
}
```

### Auto-Generated Fields

Fields with `autoGenerated: true` are populated by the system and displayed as read-only in the UI:

- **Document fields**: `pageCount`, `fileSize`, `uploadedAt`, `originalFilename`
- **Chunk fields**: `token_count`, `heading_1` through `heading_6`, `section_path`, `heading_level`, `position_in_document`, `total_chunks`

These fields are automatically populated during upload (document) or chunking (chunk) based on what fields exist in the selected schema.

### Field Validation Rules

```typescript
interface FieldValidation {
  // String validation
  minLength?: number;
  maxLength?: number;
  pattern?: string;     // Regex pattern

  // Numeric validation
  min?: number;
  max?: number;
  integer?: boolean;    // Integers only

  // Array validation
  minItems?: number;
  maxItems?: number;
}
```

### Metadata Schema

```typescript
interface MetadataSchema {
  id: string;
  name: string;
  description?: string;
  documentFields: FieldDefinition[];
  chunkFields: FieldDefinition[];
  chunkEnrichmentPrompt?: string;
  createdAt?: string;
  updatedAt?: string;
}
```

## API Endpoints

### List Schemas

```
GET /api/schemas
```

Returns all schemas.

**Response**: `MetadataSchema[]`

### Get Schema

```
GET /api/schemas/:id
```

Returns a single schema.

**Response**: `MetadataSchema`

### Create Schema

```
POST /api/schemas
```

**Request Body**:
```json
{
  "name": "RAG Document Schema",
  "description": "Metadata for RAG pipeline documents",
  "documentFields": [
    {
      "id": "uuid-1",
      "name": "source_type",
      "label": "Source Type",
      "type": "string",
      "required": true
    }
  ],
  "chunkFields": [
    {
      "id": "uuid-2",
      "name": "importance",
      "label": "Importance Score",
      "type": "numeric",
      "required": false,
      "validation": { "min": 1, "max": 10, "integer": true }
    }
  ]
}
```

**Response**: Created `MetadataSchema`

### Update Schema

```
PATCH /api/schemas/:id
```

All fields are optional.

**Request Body**:
```json
{
  "name": "Updated Name",
  "description": "New description",
  "documentFields": [...],
  "chunkFields": [...]
}
```

**Response**: Updated `MetadataSchema`

### Delete Schema

```
DELETE /api/schemas/:id
```

Uploads using this schema will have `schema_id` set to `NULL`.

**Response**: `{ "success": true }`

### Apply Schema to Upload

```
PATCH /api/uploads/:id/schema
```

**Request Body**:
```json
{
  "schemaId": "schema-uuid"  // or null to remove
}
```

## Frontend Implementation

### React Query Hooks

Located in `client/src/hooks/useSchemas.ts`:

```typescript
// Fetch all schemas
useSchemas()

// Fetch single schema
useSchema(schemaId: string | null)

// Mutations
useCreateSchema()
useUpdateSchema()
useDeleteSchema()
useApplySchemaToUpload()
```

**Caching**: 30-minute `staleTime` for all schema queries.

### UI Components

| Component | File | Purpose |
|-----------|------|---------|
| `SchemaSelector` | `components/SchemaSelector.tsx` | Dropdown to select/search schemas |
| `SchemaEditorDialog` | `components/SchemaEditorDialog.tsx` | Create/edit schema dialog |
| `FieldEditor` | `components/FieldEditor.tsx` | Edit single field definition |
| `DynamicField` | `components/DynamicField.tsx` | Render field input by type |
| `TagsInput` | `components/TagsInput.tsx` | Array field editor |
| `JsonKeyValueEditor` | `components/JsonKeyValueEditor.tsx` | JSON field editor |

### Editor Integration

In the document editor (`MetadataPanel`), the schema drives all metadata fields:

**Document Tab:**
1. **Schema Selector** to change the document's schema
2. **Document Title** (always editable, separate from schema)
3. **Editable Fields** accordion: Schema fields with `autoGenerated: false`
4. **Auto-Generated** accordion: Schema fields with `autoGenerated: true` (read-only display)

**Chunk Tab:**
1. **Editable Fields** accordion: Schema chunk fields with `autoGenerated: false`
2. **Auto-Generated** accordion: Schema chunk fields with `autoGenerated: true` (read-only display)

The MetadataPanel only shows fields defined in the selected schema. If no schema is selected or the schema has no fields, appropriate messages are shown.

## Usage Patterns

### Creating a Schema

```typescript
// Via hook
const createSchema = useCreateSchema();

await createSchema.mutateAsync({
  name: "Legal Document",
  description: "For legal documents and contracts",
  documentFields: [
    {
      id: crypto.randomUUID(),
      name: "document_type",
      label: "Document Type",
      type: "string",
      required: true,
    },
    {
      id: crypto.randomUUID(),
      name: "parties",
      label: "Involved Parties",
      type: "array",
      required: false,
    }
  ],
  chunkFields: [
    {
      id: crypto.randomUUID(),
      name: "clause_type",
      label: "Clause Type",
      type: "string",
      required: false,
    }
  ]
});
```

### Applying to Upload

```typescript
// Via hook
const applySchema = useApplySchemaToUpload();

await applySchema.mutateAsync({
  uploadId: "upload-uuid",
  schemaId: "schema-uuid"  // or null to remove
});
```

### Working with Custom Field Values

```typescript
// Custom fields are stored as Record<string, CustomFieldValue>
type CustomFieldValue = string | number | string[] | Record<string, string>;

// Example document custom metadata
const customMetadata = {
  document_type: "contract",        // string
  parties: ["Acme Corp", "User"],   // array
  priority: 5,                      // numeric
  attributes: { status: "draft" }   // json
};
```

## Validation

### Field Name Rules

- Must start with lowercase letter
- Only lowercase letters, numbers, underscores
- 1-50 characters
- Regex: `/^[a-z][a-z0-9_]*$/`

### Validation Function

```typescript
function validateFieldValue(
  value: CustomFieldValue | undefined,
  field: FieldDefinition
): string | null {
  // Returns error message or null if valid
  // Checks: required, minLength, maxLength, pattern,
  //         min, max, integer, minItems, maxItems
}
```

## Helper Functions

From `shared/metadata-schema.ts`:

```typescript
// Get default value for field type
getDefaultValueForType(type: FieldType): CustomFieldValue

// Create empty field definition
createEmptyField(type: FieldType = 'string', autoGenerated: boolean = false): FieldDefinition

// Generate UUID for field
generateFieldId(): string

// Validate field value against definition
validateFieldValue(value: CustomFieldValue | undefined, field: FieldDefinition): string | null
```

## Security Considerations

1. **Deletion**: Uploads retain custom values when schema deleted
2. **Validation**: Server-side Zod validation on all mutations
