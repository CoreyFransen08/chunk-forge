# Chunk Enrichment Agent

This document describes the AI-powered chunk metadata enrichment system in ChunkForge, which uses Mastra agents to automatically populate custom metadata fields based on user-defined prompts.

## Overview

The Chunk Enrichment Agent analyzes chunk content and extracts structured metadata based on:
- User-defined chunk fields from the schema
- A custom enrichment prompt that guides the AI

**Key Features:**
- Dynamic Zod schema generation from `FieldDefinition[]`
- Structured output using OpenAI's JSON Schema mode
- Single chunk and batch enrichment support
- Test mode for iterating on prompts (first 3, 5, or 10 chunks)

## Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                           Frontend                                   │
├─────────────────────────────────────────────────────────────────────┤
│  MetadataPanel.tsx                                                  │
│  ├── Document Tab: Batch enrichment with test mode dropdown         │
│  │   └── Select: "Test first 3" | "Test first 5" | "Test first 10" │
│  │   └── Button: "Enrich" → useEnrichChunks()                       │
│  └── Chunk Tab: Single chunk enrichment button                      │
│      └── Button: "Enrich This Chunk with AI" → useEnrichChunk()     │
├─────────────────────────────────────────────────────────────────────┤
│  useChunkEnrichment.ts (React Query Hooks)                          │
│  ├── useEnrichChunk() → POST /api/agents/enrich-chunk/:uploadId/:id │
│  └── useEnrichChunks() → POST /api/agents/enrich-chunks/:uploadId   │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│                           Backend                                    │
├─────────────────────────────────────────────────────────────────────┤
│  server/routes/agents.ts                                            │
│  ├── POST /api/agents/enrich-chunk/:uploadId/:chunkId               │
│  │   └── Enriches single chunk, updates DB                          │
│  └── POST /api/agents/enrich-chunks/:uploadId?limit=N               │
│      └── Batch enrichment with optional limit                       │
├─────────────────────────────────────────────────────────────────────┤
│  server/agents/chunk-enrichment-agent.ts                            │
│  ├── buildDynamicSchema() → Zod schema from FieldDefinition[]       │
│  ├── createEnrichmentAgent() → Mastra Agent with user prompt        │
│  ├── enrichChunkMetadata() → Single chunk processing                │
│  └── enrichChunksMetadata() → Batch processing with progress        │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│                        Mastra / OpenAI                              │
├─────────────────────────────────────────────────────────────────────┤
│  Agent.generate() with structuredOutput                             │
│  └── Model: gpt-4o-mini                                             │
│  └── Returns: Typed object matching dynamic Zod schema              │
└─────────────────────────────────────────────────────────────────────┘
```

## Core Components

### 1. Dynamic Schema Builder

**File:** `server/agents/chunk-enrichment-agent.ts`

The `buildDynamicSchema()` function converts user-defined `FieldDefinition[]` into a Zod schema at runtime:

```typescript
export function buildDynamicSchema(
  fields: FieldDefinition[]
): z.ZodObject<Record<string, z.ZodTypeAny>>
```

**Type Mapping:**

| FieldType | Zod Schema | Notes |
|-----------|------------|-------|
| `string` | `z.string()` | Supports minLength, maxLength validation |
| `numeric` | `z.number()` | Supports min, max, integer validation |
| `array` | `z.array(z.string())` | Supports minItems, maxItems validation |
| `json` | `z.record(z.string(), z.string())` | Flat key-value pairs only |

**Important:** Only non-auto-generated fields are included in the schema. Fields with `autoGenerated: true` are skipped.

**OpenAI Structured Output Constraints:**

OpenAI's structured output mode has specific JSON Schema requirements that affect how we build the Zod schema:

1. **All properties must be in `required` array** - OpenAI doesn't support truly optional properties. We use `.nullable()` instead of `.optional()` for non-required fields.

2. **`additionalProperties` must have a `type` key** - `z.any()` and `z.unknown()` produce invalid schemas. For `json` fields, we use `z.record(z.string(), z.string())` (string values only).

3. **Schema must be strict** - We use `z.object({...}).strict()` to prevent extra properties.

```typescript
// Correct: nullable for optional fields
shape[field.name] = field.required ? baseSchema : baseSchema.nullable();

// Correct: string values for json type (not z.any())
case "json":
  baseSchema = z.record(z.string(), z.string());
```

### 2. Enrichment Agent

**File:** `server/agents/chunk-enrichment-agent.ts`

The `createEnrichmentAgent()` function creates a Mastra agent with the user's enrichment prompt:

```typescript
export function createEnrichmentAgent(enrichmentPrompt: string): Agent {
  return new Agent({
    name: "chunk-enrichment-agent",
    instructions: `You are a chunk metadata extraction specialist...

USER INSTRUCTIONS:
${enrichmentPrompt}

GUIDELINES:
- Analyze the chunk content carefully...`,
    model: "openai/gpt-4o-mini",
  });
}
```

### 3. Enrichment Functions

**Single Chunk:**
```typescript
export async function enrichChunkMetadata(
  chunk: Chunk,
  schema: MetadataSchema
): Promise<Record<string, any>>
```

**Batch Processing:**
```typescript
export async function enrichChunksMetadata(
  chunks: Chunk[],
  schema: MetadataSchema,
  onProgress?: (completed: number, total: number) => void
): Promise<ChunkEnrichmentResult[]>
```

### 4. Helper Functions

```typescript
// Get editable fields from schema
getEditableChunkFields(schema: MetadataSchema): FieldDefinition[]

// Check if enrichment is available
canEnrichChunks(schema: MetadataSchema | null): boolean
```

## API Endpoints

### Single Chunk Enrichment

```
POST /api/agents/enrich-chunk/:uploadId/:chunkId
```

**Response:**
```json
{
  "chunk": { /* Updated chunk object */ },
  "enrichedFields": {
    "summary": "This chunk discusses...",
    "keywords": ["AI", "machine learning"],
    "category": "technical"
  }
}
```

### Batch Enrichment

```
POST /api/agents/enrich-chunks/:uploadId?limit=5
```

**Query Parameters:**
- `limit` (optional): Number of chunks to process (for testing)

**Response:**
```json
{
  "results": [
    {
      "chunkId": "uuid-1",
      "enrichedFields": { "summary": "..." },
      "success": true
    },
    {
      "chunkId": "uuid-2",
      "enrichedFields": {},
      "success": false,
      "error": "Rate limit exceeded"
    }
  ],
  "summary": {
    "enriched": 4,
    "failed": 1,
    "total": 50,
    "processed": 5
  }
}
```

## Frontend Integration

### React Query Hooks

**File:** `client/src/hooks/useChunkEnrichment.ts`

```typescript
// Single chunk enrichment
const enrichChunk = useEnrichChunk();
enrichChunk.mutate({ uploadId, chunkId });

// Batch enrichment with limit
const enrichChunks = useEnrichChunks();
enrichChunks.mutate({ uploadId, limit: 5 }); // Test first 5
enrichChunks.mutate({ uploadId });            // All chunks
```

### UI Components

**File:** `client/src/components/MetadataPanel.tsx`

The enrichment UI appears when:
1. A schema is selected
2. The schema has a `chunkEnrichmentPrompt`
3. The schema has at least one non-auto-generated chunk field

**Document Tab - Batch Enrichment:**
```tsx
<Select value={enrichLimit} onValueChange={setEnrichLimit}>
  <SelectItem value="3">Test first 3</SelectItem>
  <SelectItem value="5">Test first 5</SelectItem>
  <SelectItem value="10">Test first 10</SelectItem>
  <SelectItem value="all">All chunks</SelectItem>
</Select>
<Button onClick={handleEnrichChunks}>
  <Sparkles /> Enrich
</Button>
```

**Chunk Tab - Single Enrichment:**
```tsx
<Button onClick={handleEnrichChunk}>
  <Sparkles /> Enrich This Chunk with AI
</Button>
```

## Data Flow

### Enrichment Process

1. **User triggers enrichment** (button click in MetadataPanel)
2. **Frontend mutation** calls API endpoint
3. **Backend fetches** upload, schema, and chunk(s) from database
4. **Validation checks:**
   - Upload exists
   - Schema has `chunkEnrichmentPrompt`
   - Schema has editable chunk fields
5. **Dynamic schema built** from `FieldDefinition[]`
6. **Mastra agent created** with user's prompt as instructions
7. **OpenAI API called** with structured output schema
8. **Response parsed** and validated against Zod schema
9. **Database updated** - enriched values merged into `chunk.metadata.custom`
10. **Frontend invalidates** chunks query to refresh UI

### Storage Location

All enriched values are stored in `chunk.metadata.custom`, regardless of whether the field name matches a "standard" chunk field (like `tags`, `keywords`, `summary`):

```typescript
// Before enrichment
chunk.metadata = {
  token_count: 150,
  heading_1: "Introduction",
  tags: [],           // May exist at root from chunk creation
  custom: {}
}

// After enrichment
chunk.metadata = {
  token_count: 150,
  heading_1: "Introduction",
  tags: [],           // Root level unchanged
  custom: {
    tags: ["Cutworms", "Pest Management"],  // Enriched values in custom
    summary: "This chunk introduces the concept of...",
    keywords: ["AI", "introduction"],
    importance: 8
  }
}
```

### Read/Write Consistency

**Important:** The frontend uses a specific read order to ensure enriched values are displayed correctly:

```typescript
// For editable (non-autoGenerated) fields:
// 1. Check custom FIRST (where enrichment saves)
// 2. Fall back to root level if custom is empty
const customValue = chunkMetadata.custom?.[field.name];
const rootValue = (chunkMetadata as any)[field.name];
const value = customValue !== undefined && customValue !== null
  ? customValue
  : rootValue;
```

**Why this matters:** Original chunks may have empty arrays at the root level (e.g., `tags: []`). Without this read order, the empty root array would take precedence over enriched values in `custom`.

**Consistency rule:** Both AI enrichment AND manual user edits save to `custom` for editable fields. This ensures:
- Enriched values always display correctly
- Manual edits don't conflict with enrichment
- Clear separation between auto-generated (root) and user/AI-defined (custom) values

## Schema Requirements

For enrichment to be available, the schema must have:

1. **`chunkEnrichmentPrompt`** - User-defined prompt (max 5000 chars)
2. **At least one chunk field** with `autoGenerated: false`

### Example Schema Setup

```typescript
{
  name: "Research Paper Schema",
  chunkEnrichmentPrompt: `Analyze each chunk and extract:
- A concise summary for {{summary}}
- Key topics as {{keywords}}
- Relevance score (1-10) for {{importance}}`,
  chunkFields: [
    { name: "summary", type: "string", autoGenerated: false },
    { name: "keywords", type: "array", autoGenerated: false },
    { name: "importance", type: "numeric", autoGenerated: false },
    { name: "token_count", type: "numeric", autoGenerated: true }
  ]
}
```

## Error Handling

| Error | HTTP Status | Cause |
|-------|-------------|-------|
| "Upload not found" | 404 | Invalid uploadId |
| "Upload has no schema assigned" | 400 | Document has no schema selected |
| "Schema has no enrichment prompt configured" | 400 | Schema missing `chunkEnrichmentPrompt` |
| "AI service not configured" | 503 | Missing `OPENAI_API_KEY` |

## Environment Variables

| Variable | Required | Description |
|----------|----------|-------------|
| `OPENAI_API_KEY` | Yes | OpenAI API key for gpt-4o-mini |

## Performance Considerations

- **Model:** Uses `gpt-4o-mini` for cost-effective processing
- **Sequential Processing:** Chunks processed one at a time to avoid rate limits
- **Test Mode:** Use limit parameter to test prompts on subset before full run
- **No Caching:** Results are not cached; re-running enrichment overwrites previous values

## Related Files

| File | Purpose |
|------|---------|
| `server/agents/chunk-enrichment-agent.ts` | Core agent logic |
| `server/agents/index.ts` | Barrel exports |
| `server/routes/agents.ts` | API endpoints |
| `client/src/hooks/useChunkEnrichment.ts` | React Query hooks |
| `client/src/components/MetadataPanel.tsx` | UI integration |
| `client/src/components/SchemaEditorDialog.tsx` | Enrichment prompt editor |
| `shared/metadata-schema.ts` | Schema type definitions |
