import { Agent } from "@mastra/core/agent";
import { z } from "zod";
import type { FieldDefinition, MetadataSchema } from "@shared/metadata-schema";
import type { Chunk } from "@shared/schema";

/**
 * Build a dynamic Zod schema from FieldDefinition array.
 * Maps field types to appropriate Zod validators for structured output.
 */
export function buildDynamicSchema(
  fields: FieldDefinition[]
): z.ZodObject<Record<string, z.ZodTypeAny>> {
  const shape: Record<string, z.ZodTypeAny> = {};

  for (const field of fields) {
    // Skip auto-generated fields - they're populated by the system
    if (field.autoGenerated) continue;

    let baseSchema: z.ZodTypeAny;

    switch (field.type) {
      case "string":
        baseSchema = z.string().describe(field.description || field.label);

        // Apply string validation rules
        if (field.validation?.minLength !== undefined) {
          baseSchema = (baseSchema as z.ZodString).min(field.validation.minLength);
        }
        if (field.validation?.maxLength !== undefined) {
          baseSchema = (baseSchema as z.ZodString).max(field.validation.maxLength);
        }
        break;

      case "numeric":
        baseSchema = z.number().describe(field.description || field.label);

        // Apply numeric validation rules
        if (field.validation?.min !== undefined) {
          baseSchema = (baseSchema as z.ZodNumber).min(field.validation.min);
        }
        if (field.validation?.max !== undefined) {
          baseSchema = (baseSchema as z.ZodNumber).max(field.validation.max);
        }
        if (field.validation?.integer) {
          baseSchema = (baseSchema as z.ZodNumber).int();
        }
        break;

      case "array":
        baseSchema = z.array(z.string()).describe(field.description || field.label);

        // Apply array validation rules
        if (field.validation?.minItems !== undefined) {
          baseSchema = (baseSchema as z.ZodArray<z.ZodString>).min(
            field.validation.minItems
          );
        }
        if (field.validation?.maxItems !== undefined) {
          baseSchema = (baseSchema as z.ZodArray<z.ZodString>).max(
            field.validation.maxItems
          );
        }
        break;

      case "json":
        // Flat key-value JSON object - use z.string() for values since z.any()
        // doesn't work with OpenAI's structured output JSON Schema validation
        baseSchema = z
          .record(z.string(), z.string())
          .describe(field.description || field.label);
        break;

      default:
        // Fallback for unknown types - use string as safe default
        baseSchema = z.string().describe(field.label);
    }

    // OpenAI structured output requires all properties in 'required' array.
    // Use .nullable() for optional fields instead of .optional()
    shape[field.name] = field.required ? baseSchema : baseSchema.nullable();
  }

  return z.object(shape).strict();
}

/**
 * Create an enrichment agent with schema-specific instructions.
 * The user's enrichment prompt is incorporated into the agent's instructions.
 */
export function createEnrichmentAgent(enrichmentPrompt: string): Agent {
  return new Agent({
    name: "chunk-enrichment-agent",
    instructions: `You are a chunk metadata extraction specialist. Your task is to analyze text chunks and extract structured metadata fields.

USER INSTRUCTIONS:
${enrichmentPrompt}

GUIDELINES:
- Analyze the chunk content carefully and extract the requested metadata fields
- Be accurate and only extract information that is clearly present or reasonably inferable
- For optional fields that cannot be determined from the content, use null
- For required fields, make your best reasonable inference based on the content
- Keep extracted text concise and relevant
- For array fields, extract distinct, relevant items without duplicates
- For numeric fields, extract or infer appropriate numbers`,
    model: "openai/gpt-4o-mini",
  });
}

/**
 * Result of enriching chunk metadata
 */
export interface ChunkEnrichmentResult {
  chunkId: string;
  enrichedFields: Record<string, any>;
  success: boolean;
  error?: string;
}

/**
 * Enrich a single chunk's metadata using the schema's enrichment prompt.
 *
 * @param chunk - The chunk to analyze
 * @param schema - The metadata schema with enrichment prompt and field definitions
 * @returns Record of enriched field values
 * @throws Error if schema has no enrichment prompt or no editable fields
 */
export async function enrichChunkMetadata(
  chunk: Chunk,
  schema: MetadataSchema
): Promise<Record<string, any>> {
  if (!schema.chunkEnrichmentPrompt) {
    throw new Error("Schema has no enrichment prompt configured");
  }

  // Only enrich non-auto-generated fields
  const editableFields = schema.chunkFields.filter((f) => !f.autoGenerated);

  if (editableFields.length === 0) {
    return {};
  }

  const dynamicSchema = buildDynamicSchema(editableFields);
  const agent = createEnrichmentAgent(schema.chunkEnrichmentPrompt);

  // Build a description of expected fields for the prompt
  const fieldDescriptions = editableFields
    .map((f) => `- ${f.name} (${f.type}${f.required ? ", required" : ""}): ${f.label}`)
    .join("\n");

  const userPrompt = `Analyze this chunk and extract the following metadata fields:

${fieldDescriptions}

CHUNK CONTENT:
${chunk.text}`;

  // Log the schema fields being used
  console.log("\n=== CHUNK ENRICHMENT DEBUG ===");
  console.log("Chunk ID:", chunk.id);
  console.log("Chunk text length:", chunk.text.length);
  console.log("\n--- EDITABLE FIELDS ---");
  editableFields.forEach((f) => {
    console.log(`  ${f.name}: type=${f.type}, required=${f.required}, label="${f.label}"`);
  });
  console.log("\n--- ENRICHMENT PROMPT (from schema) ---");
  console.log(schema.chunkEnrichmentPrompt);
  console.log("\n--- USER PROMPT (sent to agent) ---");
  console.log(userPrompt);
  console.log("\n--- DYNAMIC SCHEMA (JSON) ---");
  // Convert Zod schema to JSON Schema for logging
  try {
    const { zodToJsonSchema } = await import("zod-to-json-schema");
    const jsonSchema = zodToJsonSchema(dynamicSchema, "enrichmentSchema");
    console.log(JSON.stringify(jsonSchema, null, 2));
  } catch (e) {
    console.log("(Could not convert to JSON schema for logging)");
    console.log("Schema shape keys:", Object.keys(dynamicSchema.shape));
  }

  const response = await agent.generate(
    [
      {
        role: "user",
        content: userPrompt,
      },
    ],
    {
      structuredOutput: {
        schema: dynamicSchema,
      },
    }
  );

  const result = response.object as Record<string, any>;

  console.log("\n--- RESPONSE DATA ---");
  console.log(JSON.stringify(result, null, 2));
  console.log("=== END ENRICHMENT DEBUG ===\n");

  return result;
}

/**
 * Enrich multiple chunks' metadata (batch processing).
 * Processes chunks sequentially to avoid rate limits.
 *
 * @param chunks - Array of chunks to process
 * @param schema - The metadata schema with enrichment prompt
 * @param onProgress - Optional callback for progress updates
 * @returns Map of chunkId to enriched fields
 */
export async function enrichChunksMetadata(
  chunks: Chunk[],
  schema: MetadataSchema,
  onProgress?: (completed: number, total: number) => void
): Promise<ChunkEnrichmentResult[]> {
  const results: ChunkEnrichmentResult[] = [];

  for (let i = 0; i < chunks.length; i++) {
    const chunk = chunks[i];

    try {
      const enrichedFields = await enrichChunkMetadata(chunk, schema);
      results.push({
        chunkId: chunk.id,
        enrichedFields,
        success: true,
      });
    } catch (error: any) {
      results.push({
        chunkId: chunk.id,
        enrichedFields: {},
        success: false,
        error: error.message || "Unknown error",
      });
    }

    // Report progress
    onProgress?.(i + 1, chunks.length);
  }

  return results;
}

/**
 * Get editable chunk field names from a schema.
 * Useful for determining if enrichment is available.
 */
export function getEditableChunkFields(schema: MetadataSchema): FieldDefinition[] {
  return schema.chunkFields.filter((f) => !f.autoGenerated);
}

/**
 * Check if a schema supports chunk enrichment.
 * Requires both an enrichment prompt and at least one editable field.
 */
export function canEnrichChunks(schema: MetadataSchema | null): boolean {
  if (!schema) return false;
  if (!schema.chunkEnrichmentPrompt) return false;
  return getEditableChunkFields(schema).length > 0;
}
